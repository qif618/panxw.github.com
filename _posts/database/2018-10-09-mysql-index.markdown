---
layout: post
category: "database"
title:  "mysql索引"
tags: [Database]
---



> 索引干什么的，如何理解  

索引用于快速找出在某个列中有一特定值的行。不使用索引，会全表，扫表越大，花费的时间越多。
如果表中查询的列有一个索引，mysql能快速到达一个位置搜寻到数据
索引就像书的字典，数据犹如数的内容，而读者相当CPU

> 索引采用B+树  

- 它采用了多叉树的结构，降低了索引结构的深度，避免了传统二叉树结构中绝大部分的随机访问操作  
- 一次性读内存中的需要查找的关键字也就越多,有效减少了磁盘IO,B+树索引查询效率稳定，也有利于进行范围查询  
- B树相比B+树的一个主要区别就在于B树的分支节点上存储着数据，B+树的数据都存储在叶子节点上，分支节点均为索引

> 索引优缺点  

查询效率快，维护效率低  


> 设计原则  

1. 不是越多越好，数据量小的表建立会增加额外的索引开销，数据变更也需要维护索引，太多的索引会增加查询优化器的选择时间
1. 常更新的表索引越少越好  
1. 不同的值比较多的列才需要建立索引  
1. 某种数据本身具备唯一性的时候，建立唯一性索引，可以保证定义的列的数据完整性，以提高查询熟度  
1. 频繁进行排序或分组的列(group by或者是order by)可以建立索引，提高搜索速度  
1. 经常用于查询条件的字段应该建立索引

<!-- more -->
> 索引操作  
	
	create index name_age on t_user(name,age);
	show index from t_user;
	drop index name_age on t_user;


> 索引注意事项  

- 创建(A, B,C)复合索引，相当于创建了(A,B,C)、(A,C)、(A)三个索引，这被称为最佳左前缀特性。  

- 对于复合索引，最常用条件放最左，依次递减。  

- 当范围查询使用第一列，查询条件仅仅能使用第一列

- 列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。

- 对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。  

- mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。


- 一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。

- 不要在列上进行运算，如select * from t_user where YEAR(create_time)



- NOT IN和<>操作都不会使用索引，将进行全表扫描。NOT IN可以NOT EXISTS代替，id<>3则可使用id>3 or id<3来代替。


> 组合索引应用场景  

有 Index (A,B,C) ——组合索引多字段是有序的，并且是个完整的BTree 索引。   
下面条件可以用上该组合索引查询：  

	A>5 
	A=5 AND B>6 
	A=5 AND B=6 AND C=7 
	A=5 AND B IN (2,3) AND C>5 

下面条件将不能用上组合索引查询： 

	
	B>5 ——查询条件不包含组合索引首列字段 
	B=6 AND C=7 ——查询条件不包含组合索引首列字段  

下面条件将能用上部分组合索引查询： 

	a>5 and b=2 ——当范围查询使用第一列，查询条件仅仅能使用第一列 
	A=5 AND B>6 AND C=2 ——范围查询使用第二列，查询条件仅仅能使用前二列



> 锁行、锁表  


	行锁锁住的是索引。
	id为聚集索引，name为普通索引，select * from s_table where name='张三' for update（记录ID为1）,如该事务未提交，
	则执行select * from s_table where id=1 for update将被阻塞。原因为索引匹配后通过回表获取数据

	如下SQL,若name不是索引，则会导致锁表，name列是索引，则行锁
	update s_table set age=10 where name='张三'
	