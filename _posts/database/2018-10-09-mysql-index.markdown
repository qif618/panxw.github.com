---
layout: post
category: "database"
title:  "mysql索引"
tags: [Database]
---


> 索引优缺点  

查询效率快，维护效率低  


> 设计原则  

1. 不是越多越好  
1. 常更新的表索引越少越好  
1. 数据量小的表最好不要建立索引  
1. 不同的值比较多的列才需要建立索引  
1. 某种数据本身具备唯一性的时候，建立唯一性索引，可以保证定义的列的数据完整性，以提高查询熟度  
1. 频繁进行排序或分组的列(group by或者是order by)可以建立索引，提高搜索速度  
1. 经常用于查询条件的字段应该建立索引

<!-- more -->
> 索引操作  
	
	create index name_age on t_user(name,age);
	show index from t_user;
	drop index name_age on t_user;


> 索引注意事项  

- 创建(A, B,C)复合索引，相当于创建了(A,B,C)、(A,C)、(A)三个索引，这被称为最佳左前缀特性。  

- 对于复合索引，最常用条件放最左，依次递减。  

- 当范围查询使用第一列，查询条件仅仅能使用第一列

- 列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。

- 对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。  

- mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。


- 一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。

- 不要在列上进行运算，如select * from t_user where YEAR(create_time)



- NOT IN和<>操作都不会使用索引，将进行全表扫描。NOT IN可以NOT EXISTS代替，id<>3则可使用id>3 or id<3来代替。


> 组合索引应用场景  

有 Index (A,B,C) ——组合索引多字段是有序的，并且是个完整的BTree 索引。   
下面条件可以用上该组合索引查询：  

	A>5 
	A=5 AND B>6 
	A=5 AND B=6 AND C=7 
	A=5 AND B IN (2,3) AND C>5 

下面条件将不能用上组合索引查询： 

	
	B>5 ——查询条件不包含组合索引首列字段 
	B=6 AND C=7 ——查询条件不包含组合索引首列字段  

下面条件将能用上部分组合索引查询： 

	a>5 and b=2 ——当范围查询使用第一列，查询条件仅仅能使用第一列 
	A=5 AND B>6 AND C=2 ——范围查询使用第二列，查询条件仅仅能使用前二列


